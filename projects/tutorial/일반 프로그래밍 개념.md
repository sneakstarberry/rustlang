# 일반 프로그래밍 개념

---

### 변수

`let`을 통해 변수를 선언 하며 기본 적으로 immutability(불변성)을 기본으로 한다. 아래와 같이 할 경우 오류가 생긴다.

```rust
fn main() {
    let x = 5;
    println!("x의값 {}", x);
    x = 6;
    println!("x의값 {}", x);
}
```

다음과 같이 해야지 오류가 발생하지 않는다.

```rust
fn main() {
    let mut x = 5; //mut를 써야지된다.
    println!("x의 값 {}", x);
    x = 6;
    println!("x의 값 {}", x);
}
```

#### 변수와 상수의 차이점

상수에는 `mut`키워드를 사용 할 수 없다. 상수는 기본 선언만으로 불변 속성이 아닌 항상 불변이다.

```rust
const MAX_PINTS: u32 = 100_000;
```

위 예제 코드는 상수에 100,000이라는 값을 할당하는 코드다. 러스트에서는 상수 이름에 대문자만 사용하며 단어 사이에 밑줄을 추가하는 규칙을 사용한다. 또한, 밑줄은 숫자 리터럴의 가독성을 높이기 위해 자릿수를 구분할 때도 사용할 수 있다.

#### 변수 가리기

이미 선언한 변수의 이름과 똑같은 이름의 변수를 선언할 수 있다. 이를 두번째 변수에 의해 가려졌다고 표현한다.

```rust
fn main() {
    let x = 5;
    
    let x = x +1;
    
    let x = x * 2;
    
    println!("x의값:{}", x); // x의값:12
}
```

### 컴파운드 타입

#### 튜플 타입

튜플은 서로 다른 타입의 여러 값을 하나의 컴파운드 타입으로 그룹화하기에 적합한 타입이다.

다음과 같이 정의한다.

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

튜플은 전체 튜플을 하나의 변수에 보관하고 패턴 매칭을 통해 튜플 값을 해체할 수 있다. 다음 예제 코드를 보자

```rust
fn main() {
    let tup = (500, 6.4, 1);
    
    let (x, y, z) = tup;
    
    println!("y의 값: {}", y);
}
```

마침표(.)를 통해 각 요소를 직접 참조할 수 있다.

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    
    let five_hundred = x.0;
    
    let six_point_four = x.1;
    let one = x.2;
}
```

#### 배열타입

튜플과 달리 배열은 각 요소가 반드시 같은 타입이어야 한다. 러스트의 배열은 다른 일부 언어의 배열과는 달리 고정된 길이다.

```rust
fn main() {
    let a = [1,2,3,4,5]
}
```

다음과 같이 길이를 정할 수 있다.

```rust
let a: [i32; 5] = [1,2,3,4,5];
let b = [3; 5] // 3의 값을 가진 길이가 5인 배열을 내보낸다.
// [3,3,3,3,3]
```

배열 요소에 접근하기

```rust
fn main() {
    let a = [1,2,3,4,5]
    
    let first = a[0];
    let second = a[1];
}
```

유효하지 않은 즉, 길이를 넘어선 배열 요소에 접근하는 경우 패닉 에러가 발생한다.

### String 연결하기

```rust
let x: String = String::from("hello");
let y: String = String::from("world");
println!("{}", [x,y].concat());
println!("{}", x+&y);
```



### 함수

함수와 변수 이름에 스네이크 케이스를 사용한다. 스네이크 케이스란? 소문자와 함께 단어를 밑줄 기호로 구분하는 형식을 말한다.

```rust
fn another_function() {
    println! ("또 다른 함수");
}
```

러스트에서 함수 선언은 fn 키워드와 함수의 이름, 그리고 괄호로 구성된다. 중괄호는 컴파일러에게 함수의 본문 시작과 끝을 알려준다.

함수의 매개변수는 다음과 같이 작성한다.

```rust
fn main() {
    another_function(5);
}
fn another_function(x: i32) {
    println!("x의 값: {}", x);
}
//여러개의 매개 변수
fn other_function(x: i32, y: i32) {
    println!("x의 값: {}", x);
    println!("y의 값: {}", y);
}
```

함수의 매개변수는 모두 같지 않아도 된다.

함수의 리턴 방식은 다음과 같다.

```rust
fn five() -> i32 {
    5
}
```

### 흐름제어

#### for 루프를 이용해 컬렉션의 각 요소 반복 처리

```rust
fn main() {
    let a = [10, 20, 30, 40, 50]
    
    for element in a.iter() {
        println!("요소의 갑시 {}", element);
    }
}
//------------------
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("발싸")
}
```



---

## 범용 컬렉션

### 벡터

 벡터를 이용하면 하나 이상의 값을 하나의 데이터 구조에 담을 수 있으며 모든 값은 메모리 상에 연속으로 저장된다.

새로운 빈 벡터를 생성하려면 다음과 같이 Vec::new 함수를 호출하면 된다.

```rust
let v: Vec<i32> = Vec::new();
```

값을 포함하는 새로운 벡터 생성

```rust
let v = vec![1,2,3];
```

##### 벡터 수정

벡터를 수정해 보자. 벡터를 생성하고 값을 추가하려면 다음과 같이 push 메서드를 사용한다.

```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

##### 벡터 해체

다른 구조체와 마찬가지로 벡터 역시 범위를 벗어날 때 drop 메서드가 호출된다.

```rust
{
    let v = vec![1,2,3,4];
    // 변수 v를 사용하는 코드를 여기에 작성한다.
} // 변수v가 범위를 벗어나면 drop메서드가 호출되어 메모리가 해체된다.
```

##### 벡터로부터 값 읽기

벡터에 저장된 값을 참조하는 방법은 크게 두 가지다.

벡터에 저장된 값에 접근하는 인덱스 문법과 get메서드를 각각 설명하고 있다.

```rust
let v = vec![1,2,3,4,5];

let third: &i32 = &v[2];
println!("세 번째 원소: {}", third);

match v.get(2) {
    Some(third) => println!("세번째 원소: {}", third),
    None => println!("세번째 원소가 없습니다."),
}
```

위의 코드에서 v의 100번째 요소를 읽으려고 하면 프로그램이 어떻게 동작할까? 패닉이 발생한다. 이유는 지정한 참조가 존재하지 않기 때문이다. 반면, get 메서드에 벡터의 크기를 벗어나는 인덱스를 전달하는 방법은 패닉이 발생하지 않고 None값을 리턴한다.

벡터에서 불변 참조를 가지면서 벡터에 새로운 값을 추가할 수 없다. 참조 값이 바뀔 수 있기 때문이다.

##### 벡터에 저장된 값을 순회하기

for루프를 이용해 벡터에 저장된 값에 대한 불변 참조를 얻어와 이를 출력하는 코드를 보여준다.

```rust
let v = vec![1,2,3,4,5];
for i in &v {
    println!("{}", i);
}
```

벡터에 저장된 값에 대한 가변 참조 순회

```rust
let mut v = vec![1,2,3,4,5];
for i in &v {
    *i += 50;
}
```

#### 열거자를 이용해 여러 타입 저장하기

 벡터는 오로지 같은 타입의 값만을 저장할 수 있다고 설명했다. 이 특징은 때로는 불편할 수 있다. 열거자를 사용하면 이러한 문제를 해결 할 수 있다.

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("블루")),
    SpreadsheetCell::Float(10.12),
]
```





